import { _ as _export_sfc, c as createElementBlock, o as openBlock, a7 as createStaticVNode } from "./chunks/framework.BpxdJHRy.js";
const __pageData = JSON.parse('{"title":"Building a Simple Retrieval-Augmented Generation (RAG) System with RAGTools","description":"","frontmatter":{},"headers":[],"relativePath":"examples/building_RAG.md","filePath":"examples/building_RAG.md","lastUpdated":null}');
const _sfc_main = { name: "examples/building_RAG.md" };
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h1 id="Building-a-Simple-Retrieval-Augmented-Generation-(RAG)-System-with-RAGTools" tabindex="-1">Building a Simple Retrieval-Augmented Generation (RAG) System with RAGTools <a class="header-anchor" href="#Building-a-Simple-Retrieval-Augmented-Generation-(RAG)-System-with-RAGTools" aria-label="Permalink to &quot;Building a Simple Retrieval-Augmented Generation (RAG) System with RAGTools {#Building-a-Simple-Retrieval-Augmented-Generation-(RAG)-System-with-RAGTools}&quot;">â€‹</a></h1><p>Let&#39;s build a Retrieval-Augmented Generation (RAG) chatbot, tailored to navigate and interact with the DataFrames.jl documentation. &quot;RAG&quot; is probably the most common and valuable pattern in Generative AI at the moment.</p><p>If you&#39;re not familiar with &quot;RAG&quot;, start with this <a href="https://towardsdatascience.com/add-your-own-data-to-an-llm-using-retrieval-augmented-generation-rag-b1958bf56a5a" target="_blank" rel="noreferrer">article</a>.</p><p>Note: You must first import <code>LinearAlgebra</code>, <code>SparseArrays</code>, and <code>Unicode</code> to use this example!</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LinearAlgebra, SparseArrays, Unicode</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> PromptingTools</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> PromptingTools</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Experimental</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">RAGTools</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## Note: RAGTools module is still experimental and will change in the future. Ideally, they will be cleaned up and moved to a dedicated package</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> JSON3, Serialization, DataFramesMeta</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Statistics</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mean</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> PT </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> PromptingTools</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RT </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> PromptingTools</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Experimental</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">RAGTools</span></span></code></pre></div><h2 id="RAG-in-Two-Lines" tabindex="-1">RAG in Two Lines <a class="header-anchor" href="#RAG-in-Two-Lines" aria-label="Permalink to &quot;RAG in Two Lines {#RAG-in-Two-Lines}&quot;">â€‹</a></h2><p>Let&#39;s put together a few text pages from DataFrames.jl docs. Simply go to <a href="https://dataframes.juliadata.org/stable/" target="_blank" rel="noreferrer">DataFrames.jl docs</a> and copy&amp;paste a few pages into separate text files. Save them in the <code>examples/data</code> folder (see some example pages provided). Ideally, delete all the noise (like headers, footers, etc.) and keep only the text you want to use for the chatbot. Remember, garbage in, garbage out!</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">files </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    joinpath</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;examples&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;data&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;database_style_joins.txt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    joinpath</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;examples&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;data&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;what_is_dataframes.txt&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Build an index of chunks, embed them, and create a lookup index of metadata/tags for each chunk</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> build_index</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(files; extract_metadata </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>Let&#39;s ask a question</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Embeds the question, finds the closest chunks in the index, and generates an answer from the closest chunks</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">answer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> airag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(index; question </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;I like dplyr, what is the equivalent in Julia?&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>AIMessage(&quot;The equivalent package in Julia to dplyr in R is DataFramesMeta.jl. It provides convenience functions for data manipulation with syntax similar to dplyr.&quot;)</span></span></code></pre></div><p>First RAG in two lines? Done!</p><p>What does it do?</p><ul><li><p><code>build_index</code> will chunk the documents into smaller pieces, embed them into numbers (to be able to judge the similarity of chunks) and, optionally, create a lookup index of metadata/tags for each chunk)</p><ul><li><code>index</code> is the result of this step and it holds your chunks, embeddings, and other metadata! Just show it ðŸ˜ƒ</li></ul></li><li><p><code>airag</code> will</p><ul><li><p>embed your question</p></li><li><p>find the closest chunks in the index (use parameters <code>top_k</code> and <code>minimum_similarity</code> to tweak the &quot;relevant&quot; chunks)</p></li><li><p>[OPTIONAL] extracts any potential tags/filters from the question and applies them to filter down the potential candidates (use <code>extract_metadata=true</code> in <code>build_index</code>, you can also provide some filters explicitly via <code>tag_filter</code>)</p></li><li><p>[OPTIONAL] re-ranks the candidate chunks (define and provide your own <code>rerank_strategy</code>, eg Cohere ReRank API)</p></li><li><p>build a context from the closest chunks (use <code>chunks_window_margin</code> to tweak if we include preceding and succeeding chunks as well, see <code>?build_context</code> for more details)</p></li></ul></li><li><p>generate an answer from the closest chunks (use <code>return_all=true</code> to see under the hood and debug your application)</p></li></ul><p>You should save the index for later to avoid re-embedding / re-extracting the document chunks!</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">serialize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;examples/index.jls&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, index)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> deserialize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;examples/index.jls&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h1 id="Evaluations" tabindex="-1">Evaluations <a class="header-anchor" href="#Evaluations" aria-label="Permalink to &quot;Evaluations {#Evaluations}&quot;">â€‹</a></h1><p>However, we want to evaluate the quality of the system. For that, we need a set of questions and answers. Ideally, we would handcraft a set of high-quality Q&amp;A pairs. However, this is time-consuming and expensive. Let&#39;s generate them from the chunks in our index!</p><h2 id="Generate-Q-and-A-pairs" tabindex="-1">Generate Q&amp;A pairs <a class="header-anchor" href="#Generate-Q-and-A-pairs" aria-label="Permalink to &quot;Generate Q&amp;A pairs {#Generate-Q-and-A-pairs}&quot;">â€‹</a></h2><p>We need to provide: chunks and sources (file paths for future reference)</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">evals </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> build_qa_evals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(RT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">chunks</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(index),</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    RT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sources</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(index);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    instructions </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;None.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    verbose </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>[ Info: Q&amp;A Sets built! (cost: $0.102)</span></span></code></pre></div><div class="tip custom-block github-alert"><p class="custom-block-title">In practice, you would review each item in this golden evaluation set (and delete any generic/poor questions). It will determine the future success of your app, so you need to make sure it&#39;s good!</p><p></p></div><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Save the evals for later</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">JSON3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;examples/evals.json&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, evals)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">evals </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> JSON3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">read</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;examples/evals.json&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, Vector{RT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">QAEvalItem});</span></span></code></pre></div><h2 id="Explore-one-Q-and-A-pair" tabindex="-1">Explore one Q&amp;A pair <a class="header-anchor" href="#Explore-one-Q-and-A-pair" aria-label="Permalink to &quot;Explore one Q&amp;A pair {#Explore-one-Q-and-A-pair}&quot;">â€‹</a></h2><p>Let&#39;s explore one evals item â€“ it&#39;s not the best quality but gives you the idea!</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">evals[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>QAEvalItem:</span></span>\n<span class="line"><span> source: examples/data/database_style_joins.txt</span></span>\n<span class="line"><span> context: Database-Style Joins</span></span>\n<span class="line"><span>Introduction to joins</span></span>\n<span class="line"><span>We often need to combine two or more data sets together to provide a complete picture of the topic we are studying. For example, suppose that we have the following two data sets:</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>julia&gt; using DataFrames</span></span>\n<span class="line"><span> question: What is the purpose of joining two or more data sets together?</span></span>\n<span class="line"><span> answer: The purpose of joining two or more data sets together is to provide a complete picture of the topic being studied.</span></span></code></pre></div><h2 id="Evaluate-this-Q-and-A-pair" tabindex="-1">Evaluate this Q&amp;A pair <a class="header-anchor" href="#Evaluate-this-Q-and-A-pair" aria-label="Permalink to &quot;Evaluate this Q&amp;A pair {#Evaluate-this-Q-and-A-pair}&quot;">â€‹</a></h2><p>Let&#39;s evaluate this QA item with a &quot;judge model&quot; (often GPT-4 is used as a judge).</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Note: that we used the same question, but generated a different context and answer via `airag`</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ctx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> airag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(index; evals[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">question, return_all </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># ctx is a RAGContext object that keeps all intermediate states of the RAG pipeline for easy evaluation</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">judged </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> aiextract</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:RAGJudgeAnswerFromContext</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ctx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">context,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ctx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">question,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ctx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">answer,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    return_type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">JudgeAllScores)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">judged</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">content</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>Dict{Symbol, Any} with 6 entries:</span></span>\n<span class="line"><span>  :final_rating =&gt; 4.8</span></span>\n<span class="line"><span>  :clarity =&gt; 5</span></span>\n<span class="line"><span>  :completeness =&gt; 4</span></span>\n<span class="line"><span>  :relevance =&gt; 5</span></span>\n<span class="line"><span>  :consistency =&gt; 5</span></span>\n<span class="line"><span>  :helpfulness =&gt; 5</span></span></code></pre></div><p>We can also run the generation + evaluation in a function (a few more metrics are available, eg, retrieval score):</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> run_qa_evals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(evals[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">], ctx;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    parameters_dict </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dict</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:top_k</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), verbose </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, model_judge </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;gpt4t&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>QAEvalResult:</span></span>\n<span class="line"><span> source: examples/data/database_style_joins.txt</span></span>\n<span class="line"><span> context: outerjoin: the output contains rows for values of the key that exist in any of the passed data frames.</span></span>\n<span class="line"><span>semijoin: Like an inner join, but output is restricted to columns from the first (left) argument.</span></span>\n<span class="line"><span> question: What is the difference between outer join and semi join?</span></span>\n<span class="line"><span> answer: The purpose of joining two or more data sets together is to combine them in order to provide a complete picture or analysis of a specific topic or dataset. By joining data sets, we can combine information from multiple sources to gain more insights and make more informed decisions.</span></span>\n<span class="line"><span> retrieval_score: 0.0</span></span>\n<span class="line"><span> retrieval_rank: nothing</span></span>\n<span class="line"><span> answer_score: 5</span></span>\n<span class="line"><span> parameters: Dict(:top_k =&gt; 3)</span></span></code></pre></div><p>Fortunately, we don&#39;t have to do this one by one â€“ let&#39;s evaluate all our Q&amp;A pairs at once.</p><h2 id="Evaluate-the-Whole-Set" tabindex="-1">Evaluate the Whole Set <a class="header-anchor" href="#Evaluate-the-Whole-Set" aria-label="Permalink to &quot;Evaluate the Whole Set {#Evaluate-the-Whole-Set}&quot;">â€‹</a></h2><p>Let&#39;s run each question &amp; answer through our eval loop in async (we do it only for the first 10 to save time). See the <code>?airag</code> for which parameters you can tweak, eg, <code>top_k</code></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">results </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> asyncmap</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(evals[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">do</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> qa_item</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # Generate an answer -- often you want the model_judge to be the highest quality possible, eg, &quot;GPT-4 Turbo&quot; (alias &quot;gpt4t)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    msg, ctx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> airag</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(index; qa_item</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">question, return_all </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        top_k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, verbose </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, model_judge </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;gpt4t&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # Evaluate the response</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # Note: you can log key parameters for easier analysis later</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    run_qa_evals</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(qa_item, ctx; parameters_dict </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dict</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">:top_k</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), verbose </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## Note that the &quot;failed&quot; evals can show as &quot;nothing&quot; (failed as in there was some API error or parsing error), so make sure to handle them.</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">results </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;!</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">isnothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">answer_score), results);</span></span></code></pre></div><p>Note: You could also use the vectorized version <code>results = run_qa_evals(evals)</code> to evaluate all items at once.</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Let&#39;s take a simple average to calculate our score</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@info</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;RAG Evals: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$(length(results))</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> results, Avg. score: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$(round(mean(x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">answer_score, results);digits</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1))</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">, Retrieval score: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">$(100</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">round(Int,mean(x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">retrieval_score,results)))</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">%&quot;</span></span></code></pre></div><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>[ Info: RAG Evals: 10 results, Avg. score: 4.6, Retrieval score: 100%</span></span></code></pre></div><p>Note: The retrieval score is 100% only because we have two small documents and running on 10 items only. In practice, you would have a much larger document set and a much larger eval set, which would result in a more representative retrieval score.</p><p>You can also analyze the results in a DataFrame:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">df </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> DataFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(results)</span></span></code></pre></div><div><div style="float:left;"><span>10Ã—8 DataFrame</span></div><div style="clear:both;"></div></div><div class="data-frame" style="overflow-x:scroll;"><table class="data-frame" style="margin-bottom:6px;"><thead><tr class="header"><th class="rowNumber" style="font-weight:bold;text-align:right;">Row</th><th style="text-align:left;">source</th><th style="text-align:left;">context</th><th style="text-align:left;">question</th><th style="text-align:left;">answer</th><th style="text-align:left;">retrieval_score</th><th style="text-align:left;">retrieval_rank</th><th style="text-align:left;">answer_score</th><th style="text-align:left;">parameters</th></tr><tr class="subheader headerLastRow"><th class="rowNumber" style="font-weight:bold;text-align:right;"></th><th title="String" style="text-align:left;">String</th><th title="String" style="text-align:left;">String</th><th title="String" style="text-align:left;">String</th><th title="SubString{String}" style="text-align:left;">SubStrinâ€¦</th><th title="Float64" style="text-align:left;">Float64</th><th title="Int64" style="text-align:left;">Int64</th><th title="Float64" style="text-align:left;">Float64</th><th title="Dict{Symbol, Int64}" style="text-align:left;">Dictâ€¦</th></tr></thead><tbody><tr><td class="rowNumber" style="font-weight:bold;text-align:right;">1</td><td style="text-align:left;">examples/data/database_style_joins.txt</td><td style="text-align:left;">Database-Style Joins\\nIntroduction to joins\\nWe often need to combine two or more data sets together to provide a complete picture of the topic we are studying. For example, suppose that we have the following two data sets:\\n\\njulia&gt; using DataFrames</td><td style="text-align:left;">What is the purpose of joining two or more data sets together?</td><td style="text-align:left;">The purpose of joining two or more data sets together is to combine the data sets based on a common key and provide a complete picture of the topic being studied.</td><td style="text-align:right;">1.0</td><td style="text-align:right;">1</td><td style="text-align:right;">5.0</td><td style="text-align:left;">Dict(:top_k=&gt;3)</td></tr><tr><td class="rowNumber" style="font-weight:bold;text-align:right;">2</td><td style="text-align:left;">examples/data/database_style_joins.txt</td><td style="text-align:left;">julia&gt; people = DataFrame(ID=[20, 40], Name=[&quot;John Doe&quot;, &quot;Jane Doe&quot;])\\n2Ã—2 DataFrame\\n Row â”‚ ID Name\\n â”‚ Int64 String\\nâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n 1 â”‚ 20 John Doe\\n 2 â”‚ 40 Jane Doe</td><td style="text-align:left;">What is the DataFrame called &#39;people&#39; composed of?</td><td style="text-align:left;">The DataFrame called &#39;people&#39; consists of two columns: &#39;ID&#39; and &#39;Name&#39;. The &#39;ID&#39; column contains integers, and the &#39;Name&#39; column contains strings.</td><td style="text-align:right;">1.0</td><td style="text-align:right;">1</td><td style="text-align:right;">4.0</td><td style="text-align:left;">Dict(:top_k=&gt;3)</td></tr><tr><td class="rowNumber" style="font-weight:bold;text-align:right;">3</td><td style="text-align:left;">examples/data/database_style_joins.txt</td><td style="text-align:left;">julia&gt; jobs = DataFrame(ID=[20, 40], Job=[&quot;Lawyer&quot;, &quot;Doctor&quot;])\\n2Ã—2 DataFrame\\n Row â”‚ ID Job\\n â”‚ Int64 String\\nâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n 1 â”‚ 20 Lawyer\\n 2 â”‚ 40 Doctor</td><td style="text-align:left;">What are the jobs and IDs listed in the dataframe?</td><td style="text-align:left;">The jobs and IDs listed in the dataframe are as follows:\\n\\nID: 20\\nJob: Lawyer\\n\\nID: 40\\nJob: Doctor</td><td style="text-align:right;">1.0</td><td style="text-align:right;">1</td><td style="text-align:right;">4.67</td><td style="text-align:left;">Dict(:top_k=&gt;3)</td></tr><tr><td class="rowNumber" style="font-weight:bold;text-align:right;">4</td><td style="text-align:left;">examples/data/database_style_joins.txt</td><td style="text-align:left;">We might want to work with a larger data set that contains both the names and jobs for each ID. We can do this using the innerjoin function:</td><td style="text-align:left;">How can we combine the names and jobs for each ID in a larger data set?</td><td style="text-align:left;">We can use the `innerjoin` function to combine the names and jobs for each ID in a larger data set.</td><td style="text-align:right;">1.0</td><td style="text-align:right;">1</td><td style="text-align:right;">4.33333</td><td style="text-align:left;">Dict(:top_k=&gt;3)</td></tr><tr><td class="rowNumber" style="font-weight:bold;text-align:right;">5</td><td style="text-align:left;">examples/data/database_style_joins.txt</td><td style="text-align:left;">julia&gt; innerjoin(people, jobs, on = :ID)\\n2Ã—3 DataFrame\\n Row â”‚ ID Name Job\\n â”‚ Int64 String String\\nâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\\n 1 â”‚ 20 John Doe Lawyer\\n 2 â”‚ 40 Jane Doe Doctor</td><td style="text-align:left;">What is the name of the person with the ID 40 and their job?</td><td style="text-align:left;">The name of the person with the ID 40 is Jane Doe and their job is Doctor.</td><td style="text-align:right;">1.0</td><td style="text-align:right;">2</td><td style="text-align:right;">4.67</td><td style="text-align:left;">Dict(:top_k=&gt;3)</td></tr><tr><td class="rowNumber" style="font-weight:bold;text-align:right;">6</td><td style="text-align:left;">examples/data/database_style_joins.txt</td><td style="text-align:left;">In relational database theory, this operation is generally referred to as a join. The columns used to determine which rows should be combined during a join are called keys.\\n\\nThe following functions are provided to perform seven kinds of joins:</td><td style="text-align:left;">What are the different kinds of joins?</td><td style="text-align:left;">The different kinds of joins are:\\n\\n1. Inner Join: Returns only the rows that have matching values in both data frames.\\n2. Left Join: Returns all rows from the left data frame and the matching rows from the right data frame.\\n3. Right Join: Returns all rows from the right data frame and the matching rows from the left data frame.\\n4. Full Outer Join: Returns all rows from both data frames and fills in missing values with null.\\n5. Cross Join: Returns the cartesian product of the rows from both data frames.\\n6. Semi Join: Returns only the rows from the left data frame that have matching values in the right data frame.\\n7. Anti Join: Returns only the rows from the left data frame that do not have matching values in the right data frame.</td><td style="text-align:right;">1.0</td><td style="text-align:right;">1</td><td style="text-align:right;">4.66667</td><td style="text-align:left;">Dict(:top_k=&gt;3)</td></tr><tr><td class="rowNumber" style="font-weight:bold;text-align:right;">7</td><td style="text-align:left;">examples/data/database_style_joins.txt</td><td style="text-align:left;">innerjoin: the output contains rows for values of the key that exist in all passed data frames.</td><td style="text-align:left;">What does the output of the inner join operation contain?</td><td style="text-align:left;">The output of the inner join operation contains only the rows for values of the key that exist in all passed data frames.</td><td style="text-align:right;">1.0</td><td style="text-align:right;">1</td><td style="text-align:right;">5.0</td><td style="text-align:left;">Dict(:top_k=&gt;3)</td></tr><tr><td class="rowNumber" style="font-weight:bold;text-align:right;">8</td><td style="text-align:left;">examples/data/database_style_joins.txt</td><td style="text-align:left;">leftjoin: the output contains rows for values of the key that exist in the first (left) argument, whether or not that value exists in the second (right) argument.</td><td style="text-align:left;">What is the purpose of the left join operation?</td><td style="text-align:left;">The purpose of the left join operation is to combine data from two tables based on a common key, where all rows from the left (first) table are included in the output, regardless of whether there is a match in the right (second) table.</td><td style="text-align:right;">1.0</td><td style="text-align:right;">1</td><td style="text-align:right;">4.66667</td><td style="text-align:left;">Dict(:top_k=&gt;3)</td></tr><tr><td class="rowNumber" style="font-weight:bold;text-align:right;">9</td><td style="text-align:left;">examples/data/database_style_joins.txt</td><td style="text-align:left;">rightjoin: the output contains rows for values of the key that exist in the second (right) argument, whether or not that value exists in the first (left) argument.</td><td style="text-align:left;">What is the purpose of the right join operation?</td><td style="text-align:left;">The purpose of the right join operation is to include all the rows from the second (right) argument, regardless of whether a match is found in the first (left) argument.</td><td style="text-align:right;">1.0</td><td style="text-align:right;">1</td><td style="text-align:right;">4.67</td><td style="text-align:left;">Dict(:top_k=&gt;3)</td></tr><tr><td class="rowNumber" style="font-weight:bold;text-align:right;">10</td><td style="text-align:left;">examples/data/database_style_joins.txt</td><td style="text-align:left;">outerjoin: the output contains rows for values of the key that exist in any of the passed data frames.\\nsemijoin: Like an inner join, but output is restricted to columns from the first (left) argument.</td><td style="text-align:left;">What is the difference between outer join and semi join?</td><td style="text-align:left;">The difference between outer join and semi join is that outer join includes rows for values of the key that exist in any of the passed data frames, whereas semi join is like an inner join but only outputs columns from the first argument.</td><td style="text-align:right;">1.0</td><td style="text-align:right;">1</td><td style="text-align:right;">4.66667</td><td style="text-align:left;">Dict(:top_k=&gt;3)</td></tr></tbody></table></div><p>We&#39;re done for today!</p><h1 id="What-would-we-do-next?" tabindex="-1">What would we do next? <a class="header-anchor" href="#What-would-we-do-next?" aria-label="Permalink to &quot;What would we do next? {#What-would-we-do-next?}&quot;">â€‹</a></h1><ul><li><p>Review your evaluation golden data set and keep only the good items</p></li><li><p>Play with the chunk sizes (max_length in build_index) and see how it affects the quality</p></li><li><p>Explore using metadata/key filters (<code>extract_metadata=true</code> in build_index)</p></li><li><p>Add filtering for semantic similarity (embedding distance) to make sure we don&#39;t pick up irrelevant chunks in the context</p></li><li><p>Use multiple indices or a hybrid index (add a simple BM25 lookup from TextAnalysis.jl)</p></li><li><p>Data processing is the most important step - properly parsed and split text could make wonders</p></li><li><p>Add re-ranking of context (see <code>rerank</code> function, you can use Cohere ReRank API)</p></li><li><p>Improve the question embedding (eg, rephrase it, generate hypothetical answers and use them to find better context)</p></li></ul><p>... and much more! See some ideas in <a href="https://www.anyscale.com/blog/a-comprehensive-guide-for-building-rag-based-llm-applications-part-1" target="_blank" rel="noreferrer">Anyscale RAG tutorial</a></p><hr><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl" target="_blank" rel="noreferrer">Literate.jl</a>.</em></p>', 53);
const _hoisted_54 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, _hoisted_54);
}
const building_RAG = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  building_RAG as default
};
